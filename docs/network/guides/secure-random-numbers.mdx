---
slug: secure-random-numbers
title: Secure Random Numbers
tags: [quickstart, solidity, javascript, python, rust, go]
authors: [dineshpinto, horiamagureanu, charlesgrover]
description: Use Flare's secure randomness in your application.
keywords:
  [
    solidity,
    javascript,
    python,
    rust,
    go,
    randomness,
    randomn-number,
    flare-time-series-oracle,
    flare-network,
  ]
sidebar_position: 6
---

import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";
import Remix from "@site/src/components/remix";
import CodeBlock from "@theme/CodeBlock";
import SecureRandomConsumer from "!!raw-loader!/examples/developer-hub-solidity/SecureRandomConsumer.sol";
import SetEvmVersionRemix from "/static/img/set-evm-version-remix.png";
import SecureRandomWeb3Js from "!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_web3.js";
import SecureRandomEthersJs from "!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_ethers.js";
import SecureRandomWeb3Py from "!!raw-loader!/examples/developer-hub-python/secure_random_coston2.py";
import SecureRandomRust from "!!raw-loader!/examples/developer-hub-rust/src/bin/secure_random_coston2.rs";
import SecureRandomGo from "!!raw-loader!/examples/developer-hub-go/coston2/secure_random.go";

This guide explains how to obtain secure random numbers on Flare. Secure randomness is generated by the [Scaling](/ftso/scaling/overview) protocol, which leverages a decentralized network of approximately 100 data providers who generate random numbers every 90 seconds.

The protocol aggregates these individual random numbers to produce a final random number that is both uniform and resistant to manipulation. The uniformity of this random number is ensured as long as at least one of the data providers remains honest, i.e. 1-of-N.
The protocol has an in-built security mechanism to detect manipulation attempts, and will warn the end user if such an attempt is detected.

<details>
<summary>**Understand the mechanism behind secure random numbers on Flare.**</summary>

As described in the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf), the Scaling protocol consists of the following phases:

1. **Commit:** During the Commit phase, data providers prepare their submissions for each of the data feeds and encode them into a 4-byte vector. Then, each data provider publishes on chain a hash commitment obtained as:

   `Hash(address, voting_epoch_id, random_number, price_data)`

   - **Random Number**: This commit includes a locally generated random number.
   - **Purpose**: The random number blinds the commit hash of the user from a search attack and is used later (once revealed) to contribute to on-chain randomness.

2. **Reveal:** During the Reveal phase, each data provider reveals all inputs to their hash commitment. As such, all locally produced random numbers become available on-chain.

3. **Signing:** After the Reveal phase, data providers perform a number of local computations relevant to the Scaling protocol, which include:

   - Computing the weighted median prices
   - Calculating the rewards

   All these are packaged into a Merkle root, which is published on-chain together with a signature of the root.

4. **Finalization:** Once enough signatures for the same Merkle root are gathered, the process is finalized.

**Secure Random Numbers**

For each voting epoch (90 seconds), an overall random number is generated from the local random numbers:

$$
R = \sum_{i} r_i \pmod{N}
$$

where $r_i$ is the local random number generated by the $i^{th}$ data provider, and $ N = 2^n $ denotes the maximum possible size of the individual $n$-bit random numbers.
This mechanism ensures that the resultant $R$ is a uniformly generated random number as long as at least any one of the inputs was an honestly generated uniformly random number.

Importantly, the Merkle root published by the data providers contains a Boolean value that tracks whether the generated random number for the current voting epoch is secure.

**Security Mechanism**

The security mechanism behind the random number generator protects the protocol against withholding attacks. An adversary could wait until all submissions are known and then choose whether or not to reveal their own commit data to influence the final result. This security mechanism measures the quality of the random number as follows:

- **True**: If there are no omissions of reveals for the commits provided by the data providers.
- **False**: If any omission exists, or if a reveal does not match the committed value.

If a data provider causes an omission (or false reveal), they will be penalized, and their random number will not be included in the random number calculation for a number of voting rounds.

</details>

## Use secure random on-chain

:::tip

You can integrate secure random numbers into your application on Flare for no cost (other than gas).

:::

<CodeBlock language="solidity" title="SecureRandomConsumer.sol">
  {SecureRandomConsumer}
</CodeBlock>

{/* prettier-ignore */}
<Remix gist="ae30de7237444059e6fac1120ecb1630">Open in Remix</Remix>
<br></br>

In addition to the `randomNumber` itself, two other variables are retrieved:

- `isSecure`: A boolean flag indicating whether the random number was generated securely. If the protocol detects any attempt to manipulate the random number, this flag is set to `false`.

- `timestamp`: The UNIX timestamp marking the end of the voting epoch during which data was collected from data providers to generate the specific number. Each voting epoch lasts for a fixed 90-second window.

:::warning[When compiling and deploying the contract]

- **Using Remix:** Set EVM version to `london` in the **Advanced Configurations** section of the **Solidity Compiler** tab:

  <img src={SetEvmVersionRemix} style={{ width: 300 }} />

- **Using Hardhat or Foundry:** Set EVM version to `london` in [hardhat.config.ts](https://github.com/flare-foundation/flare-hardhat-starter/blob/master/hardhat.config.ts#L34) or [foundry.toml](https://github.com/flare-foundation/flare-foundry-starter/blob/master/foundry.toml).

- **Using Standard Solidity JSON:** Set `evmVersion` to `london`:

  ```json
  {
    "settings": {
      "optimizer": {
        /* ... */
      },
      "evmVersion": "london"
    }
  }
  ```

- **Using `solc` CLI:** Set `--evm-version` to `london`:

  ```bash
  solc --evm-version london <args>
  ```

:::

## Use secure random off-chain

To obtain a secure random number offchain, you need two key pieces of information:

1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can use a node provider service or point to your [own RPC node](/run-node/rpc-node). A comprehensive list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.

2. **Contract Address:** The address for the `Relay` contract varies by network. You can obtain this address in two ways:

   - **From the Solidity Reference page:** Find the `Relay` address for each network on the [Solidity Reference](../solidity-reference) page.

     **OR**

   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `Relay` contract address. Refer to the specific language guides for examples:
     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)
     - [Python](/network/guides/flare-for-python-developers#make-query)
     - [Rust](/network/guides/flare-for-rust-developers#make-query)
     - [Go](/network/guides/flare-for-go-developers#make-query)

:::tip

All examples in this guide are available on the [developer-hub repository](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

<Tabs block>
  <TabItem value="JavaScript" label="JavaScript" default>
    This example shows two ways, one using [web3.js](https://github.com/web3/web3.js) and the other using [ethers.js](https://github.com/ethers-io/ethers.js/), to retrieve a secure random number on Flare Testnet Coston2.

    <Tabs groupId="web3">
      <TabItem value="web3js" label="web3.js" default>

        ```bash
        npm install web3
        ```

      </TabItem>
      <TabItem value="ethersjs" label="ethers.js">

        ```bash
        npm install ethers
        ```

      </TabItem>
    </Tabs>
    <Tabs groupId="web3">
      <TabItem value="web3js" label="web3.js">

        <CodeBlock language="javascript" title="secure_random.js">
          {SecureRandomWeb3Js}
        </CodeBlock>

      </TabItem>
      <TabItem value="ethersjs" label="ethers.js">

        <CodeBlock language="javascript" title="secure_random.js">
          {SecureRandomEthersJs}
        </CodeBlock>

      </TabItem>
    </Tabs>

  </TabItem>
  <TabItem value="Python" label="Python">

    This example uses [web3.py](https://github.com/ethereum/web3.py) to retrieve a secure random number on Flare Testnet Coston2.

    <Tabs groupId="python">
      <TabItem value="poetry" label="poetry" default>

        ```bash
        poetry add web3
        ```

      </TabItem>
      <TabItem value="pip" label="pip">

        ```bash
        pip install web3
        ```

      </TabItem>
    </Tabs>

    <CodeBlock language="python" title="secure_random.py">
      {SecureRandomWeb3Py}
    </CodeBlock>

  </TabItem>
  <TabItem value="Rust" label="Rust">

    This example uses [alloy-rs](https://github.com/alloy-rs) to retrieve a secure random number on Flare Testnet Coston2.
    Add the following dependencies to `Cargo.toml`:

    ```toml title="Cargo.toml"
    alloy = { version = "0.1", features = ["full"] }
    eyre = "0.6"
    tokio = { version = "1", features = ["rt", "rt-multi-thread", "macros"] }
    ```
    <CodeBlock language="rust" title="secure_random.rs">
      {SecureRandomRust}
    </CodeBlock>

  </TabItem>
  <TabItem value="Go" label="Go">
    This example uses the Go API from [Geth](https://geth.ethereum.org) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD from Flare Testnet Coston2.

    ```bash
    go get github.com/ethereum/go-ethereum/ethclient
    ```
    The project structure should look like:

    ```plaintext
    developer-hub-go/
    ├── coston2/
    │   └── *.go
    ├── flare/
    │   └── *.go
    ├── main.go
    ├── go.mod
    └── go.sum
    ```

    With Go, you need to manually fetch the contract's ABI and generate the Go bindings.
    Copy the [Relay ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0x5CdF9eAF3EB8b44fB696984a1420B56A7575D250&format=raw) and paste it into a file named `Relay.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.

    ```bash
    abigen --abi Relay.abi --pkg coston2 --type Relay --out coston2/Relay.go
    ```

    <CodeBlock language="go" title="coston2/secure_random.go">
      {SecureRandomGo}
    </CodeBlock>

  </TabItem>
</Tabs>
